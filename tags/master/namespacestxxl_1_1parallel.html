<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: stxxl::parallel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacestxxl_1_1parallel.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">stxxl::parallel Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1active__tag.html">active_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1binary__negate.html">binary_negate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternative to std::not2, typedefs first_argument_type and second_argument_type not needed.  <a href="classstxxl_1_1parallel_1_1binary__negate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1equal__from__less.html">equal_from_less</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs predicate for equality from strict weak ordering predicate.  <a href="classstxxl_1_1parallel_1_1equal__from__less.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1equal__to.html">equal_to</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1guarded__iterator.html">guarded_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator wrapper supporting an implicit supremum at the end of the sequence, dominating all comparisons.  <a href="classstxxl_1_1parallel_1_1guarded__iterator.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1inactive__tag.html">inactive_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1less.html">less</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1lexicographic.html">lexicographic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a pair of types lexcigraphically, ascending.  <a href="classstxxl_1_1parallel_1_1lexicographic.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1lexicographic__rev.html">lexicographic_rev</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare a pair of types lexcigraphically, descending.  <a href="classstxxl_1_1parallel_1_1lexicographic__rev.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits.html">loser_tree_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01char_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, char, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01int_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, int, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01long_01long_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, long long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01long_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01short_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, short, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01unsigned_01char_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, unsigned char, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01unsigned_01int_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, unsigned int, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01unsigned_01long_01long_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, unsigned long long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01unsigned_01long_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, unsigned long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits_3_01Stable_00_01unsigned_01short_00_01Comparator_01_4.html">loser_tree_traits&lt; Stable, unsigned short, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1loser__tree__traits__unguarded.html">loser_tree_traits_unguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01char_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, char, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01int_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, int, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01long_01long_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, long long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01long_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01short_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, short, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01unsigned_01char_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, unsigned char, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01unsigned_01int_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, unsigned int, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01unsigned_01long_01long_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, unsigned long long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01unsigned_01long_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, unsigned long, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1loser__tree__traits__unguarded_3_01Stable_00_01unsigned_01short_00_01Comparator_01_4.html">loser_tree_traits_unguarded&lt; Stable, unsigned short, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopy.html">LoserTreeCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopy&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopyBase.html">LoserTreeCopyBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopyUnguarded.html">LoserTreeCopyUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopyUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeCopyUnguardedBase.html">LoserTreeCopyUnguardedBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointer.html">LoserTreePointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointer&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointerBase.html">LoserTreePointerBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointerUnguarded.html">LoserTreePointerUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointerUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreePointerUnguardedBase.html">LoserTreePointerUnguardedBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1LoserTreeReference.html">LoserTreeReference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1NumberOfThreads.html">NumberOfThreads</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstxxl_1_1parallel_1_1Settings.html">Settings</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1Timing.html">Timing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1Timing_3_01inactive__tag_00_01must__be__int_01_4.html">Timing&lt; inactive_tag, must_be_int &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classstxxl_1_1parallel_1_1unguarded__iterator.html">unguarded_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1bb834234c3936e1b13ba2da951c4e18"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacestxxl.html#ad7f9125156ce2d31af5283aa66568f0d">int64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a></td></tr>
<tr class="separator:a1bb834234c3936e1b13ba2da951c4e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6a8e26a0140063540f45b7d8787db46"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#ac6a8e26a0140063540f45b7d8787db46">point_in_time</a></td></tr>
<tr class="separator:ac6a8e26a0140063540f45b7d8787db46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36579a3400f813b22901b94a04d6beee"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a36579a3400f813b22901b94a04d6beee">sequence_index_t</a></td></tr>
<tr class="separator:a36579a3400f813b22901b94a04d6beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7f14ee43851e5904b3f567d60ad2e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structstxxl_1_1parallel_1_1Settings.html">Settings</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#ad5b7f14ee43851e5904b3f567d60ad2e">SETTINGS</a></td></tr>
<tr class="separator:ad5b7f14ee43851e5904b3f567d60ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4865661c774238c64f75b69aa27e43a7"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a4865661c774238c64f75b69aa27e43a7">thread_index_t</a></td></tr>
<tr class="separator:a4865661c774238c64f75b69aa27e43a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a26751f85022582ef6d2df0e59ffaf4a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a26751f85022582ef6d2df0e59ffaf4a0">decode2</a> (<a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a> x, int &amp;a, int &amp;b)</td></tr>
<tr class="memdesc:a26751f85022582ef6d2df0e59ffaf4a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode two integers from one mcstl::lcas_t.  <a href="#a26751f85022582ef6d2df0e59ffaf4a0">More...</a><br/></td></tr>
<tr class="separator:a26751f85022582ef6d2df0e59ffaf4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70cd102048ff42aaf8417d165e834118"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a70cd102048ff42aaf8417d165e834118">encode2</a> (int a, int b)</td></tr>
<tr class="memdesc:a70cd102048ff42aaf8417d165e834118"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode two integers into one mcstl::lcas_t.  <a href="#a70cd102048ff42aaf8417d165e834118">More...</a><br/></td></tr>
<tr class="separator:a70cd102048ff42aaf8417d165e834118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c171548ec89421ea7c9bcabe7cb730d"><td class="memTemplParams" colspan="2">template&lt;typename DiffType , typename DiffTypeOutputIterator &gt; </td></tr>
<tr class="memitem:a5c171548ec89421ea7c9bcabe7cb730d"><td class="memTemplItemLeft" align="right" valign="top">DiffTypeOutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a5c171548ec89421ea7c9bcabe7cb730d">equally_split</a> (DiffType n, <a class="el" href="namespacestxxl_1_1parallel.html#a4865661c774238c64f75b69aa27e43a7">thread_index_t</a> p, DiffTypeOutputIterator s)</td></tr>
<tr class="memdesc:a5c171548ec89421ea7c9bcabe7cb730d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a sequence into parts of almost equal size.  <a href="#a5c171548ec89421ea7c9bcabe7cb730d">More...</a><br/></td></tr>
<tr class="separator:a5c171548ec89421ea7c9bcabe7cb730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c800542afe00a796a68b7ff380f145"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorPair &gt; </td></tr>
<tr class="memitem:aa4c800542afe00a796a68b7ff380f145"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; typename <br class="typebreak"/>
RandomAccessIteratorPair::first_type &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#aa4c800542afe00a796a68b7ff380f145">iterpair_size</a> (const RandomAccessIteratorPair &amp;p)</td></tr>
<tr class="memdesc:aa4c800542afe00a796a68b7ff380f145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Length of a sequence described by a pair of iterators.  <a href="#aa4c800542afe00a796a68b7ff380f145">More...</a><br/></td></tr>
<tr class="separator:aa4c800542afe00a796a68b7ff380f145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d4d645bf18e740b66389c3b43f7368"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:a20d4d645bf18e740b66389c3b43f7368"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a20d4d645bf18e740b66389c3b43f7368">median_of_three_iterators</a> (RandomAccessIterator a, RandomAccessIterator b, RandomAccessIterator c, Comparator &amp;comp)</td></tr>
<tr class="memdesc:a20d4d645bf18e740b66389c3b43f7368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the median of three referenced elements, according to <code>comp</code>.  <a href="#a20d4d645bf18e740b66389c3b43f7368">More...</a><br/></td></tr>
<tr class="separator:a20d4d645bf18e740b66389c3b43f7368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284859a5b7d812a5c36e0f8d4f7c2cb7"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a284859a5b7d812a5c36e0f8d4f7c2cb7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a284859a5b7d812a5c36e0f8d4f7c2cb7">merge_advance</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_length, Comparator comp)</td></tr>
<tr class="memdesc:a284859a5b7d812a5c36e0f8d4f7c2cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_length</code> smallest elements.  <a href="#a284859a5b7d812a5c36e0f8d4f7c2cb7">More...</a><br/></td></tr>
<tr class="separator:a284859a5b7d812a5c36e0f8d4f7c2cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca0013e80c8073be73c5e579f3e640b"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a9ca0013e80c8073be73c5e579f3e640b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a9ca0013e80c8073be73c5e579f3e640b">merge_advance_movc</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_length, Comparator comp)</td></tr>
<tr class="memdesc:a9ca0013e80c8073be73c5e579f3e640b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_length</code> smallest elements.  <a href="#a9ca0013e80c8073be73c5e579f3e640b">More...</a><br/></td></tr>
<tr class="separator:a9ca0013e80c8073be73c5e579f3e640b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a59047b9255741339dc51f844b5583c"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a6a59047b9255741339dc51f844b5583c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a6a59047b9255741339dc51f844b5583c">merge_advance_usual</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_length, Comparator comp)</td></tr>
<tr class="memdesc:a6a59047b9255741339dc51f844b5583c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_length</code> smallest elements.  <a href="#a6a59047b9255741339dc51f844b5583c">More...</a><br/></td></tr>
<tr class="separator:a6a59047b9255741339dc51f844b5583c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c019cca175eda4487ec810dd020a9ad"><td class="memTemplParams" colspan="2">template&lt;typename RanSeqs , typename RankType , typename RankIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:a1c019cca175eda4487ec810dd020a9ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a1c019cca175eda4487ec810dd020a9ad">multiseq_partition</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankIterator begin_offsets, Comparator comp=std::less&lt; typename std::iterator_traits&lt; typename std::iterator_traits&lt; RanSeqs &gt;::value_type::first_type &gt;::value_type &gt;())</td></tr>
<tr class="memdesc:a1c019cca175eda4487ec810dd020a9ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence.  <a href="#a1c019cca175eda4487ec810dd020a9ad">More...</a><br/></td></tr>
<tr class="separator:a1c019cca175eda4487ec810dd020a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82de8c30e09e4ccc486e6b17edd3adcb"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename RanSeqs , typename RankType , typename Comparator &gt; </td></tr>
<tr class="memitem:a82de8c30e09e4ccc486e6b17edd3adcb"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a82de8c30e09e4ccc486e6b17edd3adcb">multiseq_selection</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankType &amp;offset, Comparator comp=std::less&lt; ValueType &gt;())</td></tr>
<tr class="memdesc:a82de8c30e09e4ccc486e6b17edd3adcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the element at a certain global rank from several sorted sequences.  <a href="#a82de8c30e09e4ccc486e6b17edd3adcb">More...</a><br/></td></tr>
<tr class="separator:a82de8c30e09e4ccc486e6b17edd3adcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439597312364d38e18969320e80bc129"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a439597312364d38e18969320e80bc129"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a439597312364d38e18969320e80bc129">multiway_merge_3_combined</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="separator:a439597312364d38e18969320e80bc129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c13d00942b0be389283b261a858caf8"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename RAI, typename C &gt; class Iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a3c13d00942b0be389283b261a858caf8"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a3c13d00942b0be389283b261a858caf8">multiway_merge_3_variant</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:a3c13d00942b0be389283b261a858caf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highly efficient 3-way merging procedure.  <a href="#a3c13d00942b0be389283b261a858caf8">More...</a><br/></td></tr>
<tr class="separator:a3c13d00942b0be389283b261a858caf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2a0e0015c97ab9ff2e3e4ec80db9a0"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a4c2a0e0015c97ab9ff2e3e4ec80db9a0"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a4c2a0e0015c97ab9ff2e3e4ec80db9a0">multiway_merge_4_combined</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="separator:a4c2a0e0015c97ab9ff2e3e4ec80db9a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c2274c44fdedc2319c268ed5ca6a10"><td class="memTemplParams" colspan="2">template&lt;template&lt; typename RAI, typename C &gt; class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a22c2274c44fdedc2319c268ed5ca6a10"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a22c2274c44fdedc2319c268ed5ca6a10">multiway_merge_4_variant</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:a22c2274c44fdedc2319c268ed5ca6a10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highly efficient 4-way merging procedure.  <a href="#a22c2274c44fdedc2319c268ed5ca6a10">More...</a><br/></td></tr>
<tr class="separator:a22c2274c44fdedc2319c268ed5ca6a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad15157bfb8238c8f9ac5afe767ce562"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:aad15157bfb8238c8f9ac5afe767ce562"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#aad15157bfb8238c8f9ac5afe767ce562">multiway_merge_bubble</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:aad15157bfb8238c8f9ac5afe767ce562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic multi-way merging procedure.  <a href="#aad15157bfb8238c8f9ac5afe767ce562">More...</a><br/></td></tr>
<tr class="separator:aad15157bfb8238c8f9ac5afe767ce562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc280c86cbd6e4d43411436b03474f71"><td class="memTemplParams" colspan="2">template&lt;typename LoserTreeType , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:adc280c86cbd6e4d43411436b03474f71"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#adc280c86cbd6e4d43411436b03474f71">multiway_merge_loser_tree</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:adc280c86cbd6e4d43411436b03474f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-way merging procedure for a high branching factor, guarded case.  <a href="#adc280c86cbd6e4d43411436b03474f71">More...</a><br/></td></tr>
<tr class="separator:adc280c86cbd6e4d43411436b03474f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2c87e19cd9f0d643d7b83171b41dc8"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:aaa2c87e19cd9f0d643d7b83171b41dc8"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#aaa2c87e19cd9f0d643d7b83171b41dc8">multiway_merge_loser_tree_combined</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="separator:aaa2c87e19cd9f0d643d7b83171b41dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4fbefe8472ef6c9bd3337f8622defe4"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:ae4fbefe8472ef6c9bd3337f8622defe4"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#ae4fbefe8472ef6c9bd3337f8622defe4">multiway_merge_loser_tree_sentinel</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="separator:ae4fbefe8472ef6c9bd3337f8622defe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f66fdbecf8c016abb2d0ceb7995aca"><td class="memTemplParams" colspan="2">template&lt;typename LoserTreeType , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a76f66fdbecf8c016abb2d0ceb7995aca"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a76f66fdbecf8c016abb2d0ceb7995aca">multiway_merge_loser_tree_unguarded</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:a76f66fdbecf8c016abb2d0ceb7995aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-way merging procedure for a high branching factor, unguarded case.  <a href="#a76f66fdbecf8c016abb2d0ceb7995aca">More...</a><br/></td></tr>
<tr class="separator:a76f66fdbecf8c016abb2d0ceb7995aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d13b315f0f85f8b95a70ffae6aa5013"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename RandomAccessIterator3 , typename Comparator &gt; </td></tr>
<tr class="memitem:a3d13b315f0f85f8b95a70ffae6aa5013"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a3d13b315f0f85f8b95a70ffae6aa5013">parallel_merge_advance</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, RandomAccessIterator3 target, typename std::iterator_traits&lt; RandomAccessIterator1 &gt;::difference_type max_length, Comparator comp)</td></tr>
<tr class="memdesc:a3d13b315f0f85f8b95a70ffae6aa5013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine fallback to sequential in case the iterators of the two input sequences are of different type.  <a href="#a3d13b315f0f85f8b95a70ffae6aa5013">More...</a><br/></td></tr>
<tr class="separator:a3d13b315f0f85f8b95a70ffae6aa5013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf48d1aade19440440de912f757e2c40"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator3 , typename Comparator &gt; </td></tr>
<tr class="memitem:abf48d1aade19440440de912f757e2c40"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#abf48d1aade19440440de912f757e2c40">parallel_merge_advance</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator1 &amp;begin2, RandomAccessIterator1 end2, RandomAccessIterator3 target, typename std::iterator_traits&lt; RandomAccessIterator1 &gt;::difference_type max_length, Comparator comp)</td></tr>
<tr class="memdesc:abf48d1aade19440440de912f757e2c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel merge routine being able to merge only the <code>max_length</code> smallest elements.  <a href="#abf48d1aade19440440de912f757e2c40">More...</a><br/></td></tr>
<tr class="separator:abf48d1aade19440440de912f757e2c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b00bde7b45003ddd8c1bf2921398fd3"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a4b00bde7b45003ddd8c1bf2921398fd3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a4b00bde7b45003ddd8c1bf2921398fd3">parallel_multiway_merge_exact_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, DiffType length, DiffType total_length, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const <a class="el" href="namespacestxxl_1_1parallel.html#a4865661c774238c64f75b69aa27e43a7">thread_index_t</a> num_threads)</td></tr>
<tr class="memdesc:a4b00bde7b45003ddd8c1bf2921398fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use multisequence selection for exact splitting.  <a href="#a4b00bde7b45003ddd8c1bf2921398fd3">More...</a><br/></td></tr>
<tr class="separator:a4b00bde7b45003ddd8c1bf2921398fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78520de33ba8216acaa5f8f8e373361c"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:a78520de33ba8216acaa5f8f8e373361c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a78520de33ba8216acaa5f8f8e373361c">parallel_multiway_merge_sampling_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, DiffType length, DiffType total_length, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const <a class="el" href="namespacestxxl_1_1parallel.html#a4865661c774238c64f75b69aa27e43a7">thread_index_t</a> num_threads)</td></tr>
<tr class="memdesc:a78520de33ba8216acaa5f8f8e373361c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use sampling and binary search for in-exact splitting.  <a href="#a78520de33ba8216acaa5f8f8e373361c">More...</a><br/></td></tr>
<tr class="separator:a78520de33ba8216acaa5f8f8e373361c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75df9ec4d689280a38f39afbb4186c6a"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:a75df9ec4d689280a38f39afbb4186c6a"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; typename <br class="typebreak"/>
std::iterator_traits<br class="typebreak"/>
&lt; RandomAccessIteratorIterator &gt;<br class="typebreak"/>
::value_type::first_type &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a75df9ec4d689280a38f39afbb4186c6a">prepare_unguarded</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, Comparator comp, int &amp;min_sequence)</td></tr>
<tr class="memdesc:a75df9ec4d689280a38f39afbb4186c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a set of sequences to be merged without a (end) guard.  <a href="#a75df9ec4d689280a38f39afbb4186c6a">More...</a><br/></td></tr>
<tr class="separator:a75df9ec4d689280a38f39afbb4186c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232088ee27977d46d84c51cb373e53c9"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:a232088ee27977d46d84c51cb373e53c9"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; typename <br class="typebreak"/>
std::iterator_traits<br class="typebreak"/>
&lt; RandomAccessIteratorIterator &gt;<br class="typebreak"/>
::value_type::first_type &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a232088ee27977d46d84c51cb373e53c9">prepare_unguarded_sentinel</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, Comparator comp)</td></tr>
<tr class="memdesc:a232088ee27977d46d84c51cb373e53c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepare a set of sequences to be merged with a (end) guard (sentinel)  <a href="#a232088ee27977d46d84c51cb373e53c9">More...</a><br/></td></tr>
<tr class="separator:a232088ee27977d46d84c51cb373e53c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e1a7512c8ba10e67d358d48213ec45"><td class="memTemplParams" colspan="2">template&lt;bool Stable, bool Sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:ab4e1a7512c8ba10e67d358d48213ec45"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#ab4e1a7512c8ba10e67d358d48213ec45">sequential_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, DiffType length, Comparator comp)</td></tr>
<tr class="memdesc:ab4e1a7512c8ba10e67d358d48213ec45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merging switch.  <a href="#ab4e1a7512c8ba10e67d358d48213ec45">More...</a><br/></td></tr>
<tr class="separator:ab4e1a7512c8ba10e67d358d48213ec45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a5db0f7b56d2f0df371e426243395d7f3"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a5db0f7b56d2f0df371e426243395d7f3">lcas_t_bits</a> = sizeof(<a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>) * 8</td></tr>
<tr class="separator:a5db0f7b56d2f0df371e426243395d7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc41f9590100bc4ec31410e5decc058"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacestxxl_1_1parallel.html#a7fc41f9590100bc4ec31410e5decc058">lcas_t_mask</a> = (((<a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>)1 &lt;&lt; (<a class="el" href="namespacestxxl_1_1parallel.html#a5db0f7b56d2f0df371e426243395d7f3">lcas_t_bits</a> / 2)) - 1)</td></tr>
<tr class="separator:a7fc41f9590100bc4ec31410e5decc058"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1bb834234c3936e1b13ba2da951c4e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacestxxl.html#ad7f9125156ce2d31af5283aa66568f0d">int64</a> <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">stxxl::parallel::lcas_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Longest compare-and-swappable integer type on this platform. </p>

<p>Definition at line <a class="el" href="parallel_2types_8h_source.html#l00041">41</a> of file <a class="el" href="parallel_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac6a8e26a0140063540f45b7d8787db46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="namespacestxxl_1_1parallel.html#ac6a8e26a0140063540f45b7d8787db46">stxxl::parallel::point_in_time</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of of point in time, used for the <a class="el" href="classstxxl_1_1parallel_1_1Timing.html">Timing</a> classes. </p>

<p>Definition at line <a class="el" href="timing_8h_source.html#l00036">36</a> of file <a class="el" href="timing_8h_source.html">timing.h</a>.</p>

</div>
</div>
<a class="anchor" id="a36579a3400f813b22901b94a04d6beee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacestxxl.html#a82128fed22a58d0bc7b0eb3670def436">uint64</a> <a class="el" href="namespacestxxl_1_1parallel.html#a36579a3400f813b22901b94a04d6beee">stxxl::parallel::sequence_index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsigned integer to index elements. The total number of elements for each algorithm must fit into this type. </p>

<p>Definition at line <a class="el" href="parallel_2types_8h_source.html#l00032">32</a> of file <a class="el" href="parallel_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad5b7f14ee43851e5904b3f567d60ad2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structstxxl_1_1parallel_1_1Settings.html">Settings</a> <a class="el" href="namespacestxxl_1_1parallel.html#ad5b7f14ee43851e5904b3f567d60ad2e">stxxl::parallel::SETTINGS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience typedef to avoid to have write <code>Settings&lt;&gt;</code>. </p>

<p>Definition at line <a class="el" href="parallel_2settings_8h_source.html#l00137">137</a> of file <a class="el" href="parallel_2settings_8h_source.html">settings.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4865661c774238c64f75b69aa27e43a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespacestxxl_1_1parallel.html#a4865661c774238c64f75b69aa27e43a7">stxxl::parallel::thread_index_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unsigned integer to index a thread number. The maximum thread number must fit into this type. </p>

<p>Definition at line <a class="el" href="parallel_2types_8h_source.html#l00037">37</a> of file <a class="el" href="parallel_2types_8h_source.html">types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a26751f85022582ef6d2df0e59ffaf4a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void stxxl::parallel::decode2 </td>
          <td>(</td>
          <td class="paramtype">lcas_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decode two integers from one mcstl::lcas_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>mcstl::lcas_t to decode integers from. </td></tr>
    <tr><td class="paramname">a</td><td>First integer, to be decoded from the most-significant <code>lcas_t_bits/2</code> bits of <code>x</code>. </td></tr>
    <tr><td class="paramname">b</td><td>Second integer, to be encoded in the least-significant <code>lcas_t_bits/2</code> bits of <code>x</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacestxxl_1_1parallel.html#a70cd102048ff42aaf8417d165e834118" title="Encode two integers into one mcstl::lcas_t. ">encode2</a> </dd></dl>

<p>Definition at line <a class="el" href="base_8h_source.html#l00073">73</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

<p>References <a class="el" href="parallel_2types_8h_source.html#l00045">lcas_t_bits</a>, and <a class="el" href="parallel_2types_8h_source.html#l00049">lcas_t_mask</a>.</p>

</div>
</div>
<a class="anchor" id="a70cd102048ff42aaf8417d165e834118"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a> stxxl::parallel::encode2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Encode two integers into one mcstl::lcas_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First integer, to be encoded in the most-significant <code>lcas_t_bits/2</code> bits. </td></tr>
    <tr><td class="paramname">b</td><td>Second integer, to be encoded in the least-significant <code>lcas_t_bits/2</code> bits. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mcstl::lcas_t value encoding <code>a</code> and <code>b</code>. </dd></dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespacestxxl_1_1parallel.html#a26751f85022582ef6d2df0e59ffaf4a0" title="Decode two integers from one mcstl::lcas_t. ">decode2</a> </dd></dl>

<p>Definition at line <a class="el" href="base_8h_source.html#l00060">60</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

<p>References <a class="el" href="parallel_2types_8h_source.html#l00045">lcas_t_bits</a>.</p>

</div>
</div>
<a class="anchor" id="a5c171548ec89421ea7c9bcabe7cb730d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DiffType , typename DiffTypeOutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">DiffTypeOutputIterator stxxl::parallel::equally_split </td>
          <td>(</td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_index_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffTypeOutputIterator&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a sequence into parts of almost equal size. </p>
<p>The resulting sequence s of length p+1 contains the splitting positions when splitting the range [0,n) into parts of almost equal size (plus minus 1). The first entry is 0, the last one n. There may result empty parts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of elements </td></tr>
    <tr><td class="paramname">p</td><td>Number of parts </td></tr>
    <tr><td class="paramname">s</td><td>Splitters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End of splitter sequence, i. e. <code>s+p+1</code> </dd></dl>

<p>Definition at line <a class="el" href="equally__split_8h_source.html#l00041">41</a> of file <a class="el" href="equally__split_8h_source.html">equally_split.h</a>.</p>

<p>References <a class="el" href="utils_8h_source.html#l00056">stxxl::split()</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01447">parallel_multiway_merge_exact_splitting()</a>.</p>

</div>
</div>
<a class="anchor" id="aa4c800542afe00a796a68b7ff380f145"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIteratorPair &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt; typename RandomAccessIteratorPair::first_type &gt;::difference_type stxxl::parallel::iterpair_size </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorPair &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Length of a sequence described by a pair of iterators. </p>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00049">49</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l00470">multiway_merge_3_combined()</a>, <a class="el" href="multiway__merge_8h_source.html#l00679">multiway_merge_4_combined()</a>, <a class="el" href="multiway__merge_8h_source.html#l00748">multiway_merge_bubble()</a>, <a class="el" href="multiway__merge_8h_source.html#l00930">multiway_merge_loser_tree()</a>, <a class="el" href="multiway__merge_8h_source.html#l01131">multiway_merge_loser_tree_combined()</a>, <a class="el" href="multiway__merge_8h_source.html#l01011">multiway_merge_loser_tree_unguarded()</a>, and <a class="el" href="multiway__merge_8h_source.html#l01361">parallel_multiway_merge_sampling_splitting()</a>.</p>

</div>
</div>
<a class="anchor" id="a20d4d645bf18e740b66389c3b43f7368"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator stxxl::parallel::median_of_three_iterators </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the median of three referenced elements, according to <code>comp</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>First iterator. </td></tr>
    <tr><td class="paramname">b</td><td>Second iterator. </td></tr>
    <tr><td class="paramname">c</td><td>Third iterator. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="base_8h_source.html#l00108">108</a> of file <a class="el" href="base_8h_source.html">base.h</a>.</p>

</div>
</div>
<a class="anchor" id="a284859a5b7d812a5c36e0f8d4f7c2cb7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator stxxl::parallel::merge_advance </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_length</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant. Static switch on whether to use the conditional-move variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p>Definition at line <a class="el" href="merge_8h_source.html#l00161">161</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>

<p>References <a class="el" href="merge_8h_source.html#l00096">merge_advance_movc()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l00470">multiway_merge_3_combined()</a>, <a class="el" href="merge_8h_source.html#l00187">parallel_merge_advance()</a>, and <a class="el" href="multiway__merge_8h_source.html#l01236">sequential_multiway_merge()</a>.</p>

</div>
</div>
<a class="anchor" id="a9ca0013e80c8073be73c5e579f3e640b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator stxxl::parallel::merge_advance_movc </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_length</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant. Specially designed code should allow the compiler to generate conditional moves instead of branches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p>Definition at line <a class="el" href="merge_8h_source.html#l00096">96</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>

<p>Referenced by <a class="el" href="merge_8h_source.html#l00161">merge_advance()</a>.</p>

</div>
</div>
<a class="anchor" id="a6a59047b9255741339dc51f844b5583c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator stxxl::parallel::merge_advance_usual </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_length</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p>Definition at line <a class="el" href="merge_8h_source.html#l00048">48</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1c019cca175eda4487ec810dd020a9ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RanSeqs , typename RankType , typename RankIterator , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stxxl::parallel::multiseq_partition </td>
          <td>(</td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>begin_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>end_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankType &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankIterator&#160;</td>
          <td class="paramname"><em>begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&#160;typename&#160;std::iterator_traits&lt;typename&#160;std::iterator_traits&lt;RanSeqs&gt;&#160;::value_type::first_type&gt;::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence. </p>
<p>The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. If there are several equal elements across the split, the ones on the left side will be chosen from sequences with smaller number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_seqs</td><td>Begin of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">end_seqs</td><td>End of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">rank</td><td>The global rank to partition at. </td></tr>
    <tr><td class="paramname">begin_offsets</td><td>A random-access sequence begin where the result will be stored in. Each element of the sequence is an iterator that points to the first element on the greater part of the respective sequence. </td></tr>
    <tr><td class="paramname">comp</td><td>The ordering functor, defaults to std::less&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multiseq__selection_8h_source.html#l00102">102</a> of file <a class="el" href="multiseq__selection_8h_source.html">multiseq_selection.h</a>.</p>

<p>References <a class="el" href="uint__types_8h_source.html#l00241">max()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="utils_8h_source.html#l00255">stxxl::round_up_to_power_of_two()</a>, <a class="el" href="multiseq__selection_8h.html#a4bd0975d41d84f7e96245fec7648a780">S</a>, <a class="el" href="sort_8h_source.html#l00676">stxxl::sort()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01447">parallel_multiway_merge_exact_splitting()</a>.</p>

</div>
</div>
<a class="anchor" id="a82de8c30e09e4ccc486e6b17edd3adcb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename RanSeqs , typename RankType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType stxxl::parallel::multiseq_selection </td>
          <td>(</td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>begin_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>end_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankType &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankType &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;ValueType&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the element at a certain global rank from several sorted sequences. </p>
<p>The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_seqs</td><td>Begin of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">end_seqs</td><td>End of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">rank</td><td>The global rank to partition at. </td></tr>
    <tr><td class="paramname">offset</td><td>The rank of the selected element in the global subsequence of elements equal to the selected element. If the selected element is unique, this number is 0. </td></tr>
    <tr><td class="paramname">comp</td><td>The ordering functor, defaults to std::less. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multiseq__selection_8h_source.html#l00347">347</a> of file <a class="el" href="multiseq__selection_8h_source.html">multiseq_selection.h</a>.</p>

<p>References <a class="el" href="uint__types_8h_source.html#l00241">max()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="utils_8h_source.html#l00255">stxxl::round_up_to_power_of_two()</a>, <a class="el" href="multiseq__selection_8h.html#a4bd0975d41d84f7e96245fec7648a780">S</a>, <a class="el" href="sort_8h_source.html#l00676">stxxl::sort()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="a439597312364d38e18969320e80bc129"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_3_combined </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00470">470</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="is__sorted_8h_source.html#l00024">stxxl::is_sorted()</a>, <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="merge_8h_source.html#l00161">merge_advance()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="verbose_8h_source.html#l00220">STXXL_ASSERT</a>, <a class="el" href="verbose_8h_source.html#l00250">STXXL_DEBUG_ASSERT</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01236">sequential_multiway_merge()</a>.</p>

</div>
</div>
<a class="anchor" id="a3c13d00942b0be389283b261a858caf8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename RAI, typename C &gt; class Iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_3_variant </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highly efficient 3-way merging procedure. </p>
<p>Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into labels in C++).</p>
<p>This works well for merging up to 4 sequences.</p>
<p>Note that making the merging stable does <em>not</em> come at a performance hit.</p>
<p>Whether the merging is done guarded or unguarded is selected by the used iterator class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00384">384</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="verbose_8h_source.html#l00220">STXXL_ASSERT</a>, <a class="el" href="verbose_8h_source.html#l00192">STXXL_CHECK_EQUAL</a>, <a class="el" href="multiway__merge_8h.html#a6205501af2dd9a760b5156e4e6f220ac">STXXL_MERGE3CASE</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="a4c2a0e0015c97ab9ff2e3e4ec80db9a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_4_combined </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00679">679</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="is__sorted_8h_source.html#l00024">stxxl::is_sorted()</a>, <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="verbose_8h_source.html#l00220">STXXL_ASSERT</a>, <a class="el" href="verbose_8h_source.html#l00250">STXXL_DEBUG_ASSERT</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01236">sequential_multiway_merge()</a>.</p>

</div>
</div>
<a class="anchor" id="a22c2274c44fdedc2319c268ed5ca6a10"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; typename RAI, typename C &gt; class iterator, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_4_variant </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highly efficient 4-way merging procedure. </p>
<p>Merging is done with the algorithm implementation described by Peter Sanders. Basically, the idea is to minimize the number of necessary comparison after merging an element. The implementation trick that makes this fast is that the order of the sequences is stored in the instruction pointer (translated into goto labels in C++).</p>
<p>This works well for merging up to 4 sequences.</p>
<p>Note that making the merging stable does <em>not</em> come at a performance hit.</p>
<p>Whether the merging is done guarded or unguarded is selected by the used iterator class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00562">562</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="verbose_8h_source.html#l00220">STXXL_ASSERT</a>, <a class="el" href="verbose_8h_source.html#l00192">STXXL_CHECK_EQUAL</a>, <a class="el" href="multiway__merge_8h.html#ac65f9a547aebe1e538d166dfec40c6d9">STXXL_DECISION</a>, <a class="el" href="multiway__merge_8h.html#aa680e73606ca9127900b75d465d96a0b">STXXL_MERGE4CASE</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="aad15157bfb8238c8f9ac5afe767ce562"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_bubble </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Basic multi-way merging procedure. </p>
<p>The head elements are kept in a sorted array, new heads are inserted linearly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00748">748</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="multiway__merge_8h.html#a82b1a6a1ed1b708fb2a90a2a531acad9">POS</a>, <a class="el" href="multiway__merge_8h.html#a355413dfe67317929a53fc49617d9045">STOPS</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="adc280c86cbd6e4d43411436b03474f71"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoserTreeType , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_loser_tree </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-way merging procedure for a high branching factor, guarded case. </p>
<p>The head elements are kept in a loser tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00930">930</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>, and <a class="el" href="utils_8h_source.html#l00225">UNLIKELY</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01131">multiway_merge_loser_tree_combined()</a>, and <a class="el" href="multiway__merge_8h_source.html#l01236">sequential_multiway_merge()</a>.</p>

</div>
</div>
<a class="anchor" id="aaa2c87e19cd9f0d643d7b83171b41dc8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_loser_tree_combined </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01131">1131</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="is__sorted_8h_source.html#l00024">stxxl::is_sorted()</a>, <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="multiway__merge_8h_source.html#l00930">multiway_merge_loser_tree()</a>, <a class="el" href="multiway__merge_8h_source.html#l01011">multiway_merge_loser_tree_unguarded()</a>, <a class="el" href="verbose_8h_source.html#l00250">STXXL_DEBUG_ASSERT</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="ae4fbefe8472ef6c9bd3337f8622defe4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_loser_tree_sentinel </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01185">1185</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="is__sorted_8h_source.html#l00024">stxxl::is_sorted()</a>, <a class="el" href="multiway__merge_8h_source.html#l01011">multiway_merge_loser_tree_unguarded()</a>, <a class="el" href="verbose_8h_source.html#l00250">STXXL_DEBUG_ASSERT</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="a76f66fdbecf8c016abb2d0ceb7995aca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoserTreeType , typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::multiway_merge_loser_tree_unguarded </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-way merging procedure for a high branching factor, unguarded case. </p>
<p>The head elements are kept in a loser tree.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>No input will run out of elements during the merge. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01011">1011</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

<p>Referenced by <a class="el" href="multiway__merge_8h_source.html#l01131">multiway_merge_loser_tree_combined()</a>, and <a class="el" href="multiway__merge_8h_source.html#l01185">multiway_merge_loser_tree_sentinel()</a>.</p>

</div>
</div>
<a class="anchor" id="a3d13b315f0f85f8b95a70ffae6aa5013"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename RandomAccessIterator3 , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::parallel_merge_advance </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; RandomAccessIterator1 &gt;::difference_type&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine fallback to sequential in case the iterators of the two input sequences are of different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p>Definition at line <a class="el" href="merge_8h_source.html#l00187">187</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>

<p>References <a class="el" href="merge_8h_source.html#l00161">merge_advance()</a>.</p>

</div>
</div>
<a class="anchor" id="abf48d1aade19440440de912f757e2c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator3 , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::parallel_merge_advance </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; RandomAccessIterator1 &gt;::difference_type&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel merge routine being able to merge only the <code>max_length</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant. The functionality is projected onto parallel_multiway_merge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_length</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p>Definition at line <a class="el" href="merge_8h_source.html#l00218">218</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b00bde7b45003ddd8c1bf2921398fd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stxxl::parallel::parallel_multiway_merge_exact_splitting </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>total_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thread_index_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splitting method for parallel multi-way merge routine: use multisequence selection for exact splitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">total_length</td><td>Total length of all sequences combined. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">chunks</td><td>Output subsequences for num_threads. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Split the sequences into for num_threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01447">1447</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="equally__split_8h_source.html#l00041">equally_split()</a>, and <a class="el" href="multiseq__selection_8h_source.html#l00102">multiseq_partition()</a>.</p>

</div>
</div>
<a class="anchor" id="a78520de33ba8216acaa5f8f8e373361c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void stxxl::parallel::parallel_multiway_merge_sampling_splitting </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>total_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const thread_index_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splitting method for parallel multi-way merge routine: use sampling and binary search for in-exact splitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">total_length</td><td>Total length of all sequences combined. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">chunks</td><td>Output subsequences for num_threads. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Split the sequences into for num_threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01361">1361</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="multiway__merge_8h_source.html#l00049">iterpair_size()</a>, and <a class="el" href="sort_8h_source.html#l00676">stxxl::sort()</a>.</p>

</div>
</div>
<a class="anchor" id="a75df9ec4d689280a38f39afbb4186c6a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt; typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;::value_type::first_type &gt;::difference_type stxxl::parallel::prepare_unguarded </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>min_sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a set of sequences to be merged without a (end) guard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td></td></tr>
    <tr><td class="paramname">seqs_end</td><td></td></tr>
    <tr><td class="paramname">comp</td><td></td></tr>
    <tr><td class="paramname">min_sequence</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>(seqs_end - seqs_begin &gt; 0) </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00243">243</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="uint__types_8h_source.html#l00234">min()</a>, <a class="el" href="utils_8h_source.html#l00056">stxxl::split()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="a232088ee27977d46d84c51cb373e53c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIteratorIterator , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt; typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;::value_type::first_type &gt;::difference_type stxxl::parallel::prepare_unguarded_sentinel </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepare a set of sequences to be merged with a (end) guard (sentinel) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td></td></tr>
    <tr><td class="paramname">seqs_end</td><td></td></tr>
    <tr><td class="paramname">comp</td><td></td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l00321">321</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="utils_8h_source.html#l00056">stxxl::split()</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<a class="anchor" id="ab4e1a7512c8ba10e67d358d48213ec45"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Stable, bool Sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename DiffType , typename Comparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 stxxl::parallel::sequential_multiway_merge </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential multi-way merging switch. </p>
<p>The decision if based on the branching factor and runtime settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">length</td><td>Maximum length to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
    <tr><td class="paramname">Sentinels</td><td>The sequences have a sentinel element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p>Definition at line <a class="el" href="multiway__merge_8h_source.html#l01236">1236</a> of file <a class="el" href="multiway__merge_8h_source.html">multiway_merge.h</a>.</p>

<p>References <a class="el" href="is__sorted_8h_source.html#l00024">stxxl::is_sorted()</a>, <a class="el" href="merge_8h_source.html#l00161">merge_advance()</a>, <a class="el" href="multiway__merge_8h_source.html#l00470">multiway_merge_3_combined()</a>, <a class="el" href="multiway__merge_8h_source.html#l00679">multiway_merge_4_combined()</a>, <a class="el" href="multiway__merge_8h_source.html#l00930">multiway_merge_loser_tree()</a>, <a class="el" href="verbose_8h_source.html#l00250">STXXL_DEBUG_ASSERT</a>, and <a class="el" href="compiletime__settings_8h_source.html#l00034">STXXL_PARALLEL_PCALL</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a5db0f7b56d2f0df371e426243395d7f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t stxxl::parallel::lcas_t_bits = sizeof(<a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>) * 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of bits of <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>. </p>

<p>Definition at line <a class="el" href="parallel_2types_8h_source.html#l00045">45</a> of file <a class="el" href="parallel_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="base_8h_source.html#l00073">decode2()</a>, and <a class="el" href="base_8h_source.html#l00060">encode2()</a>.</p>

</div>
</div>
<a class="anchor" id="a7fc41f9590100bc4ec31410e5decc058"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a> stxxl::parallel::lcas_t_mask = (((<a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a>)1 &lt;&lt; (<a class="el" href="namespacestxxl_1_1parallel.html#a5db0f7b56d2f0df371e426243395d7f3">lcas_t_bits</a> / 2)) - 1)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespacestxxl_1_1parallel.html#a1bb834234c3936e1b13ba2da951c4e18">lcas_t</a> with the right half of bits set to 1. </p>

<p>Definition at line <a class="el" href="parallel_2types_8h_source.html#l00049">49</a> of file <a class="el" href="parallel_2types_8h_source.html">types.h</a>.</p>

<p>Referenced by <a class="el" href="base_8h_source.html#l00073">decode2()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacestxxl.html">stxxl</a></li><li class="navelem"><a class="el" href="namespacestxxl_1_1parallel.html">parallel</a></li>
    <li class="footer"><a href="http://github.com/stxxl/stxxl/commit/263df0c54dc168212d1c7620e3c10c93791c9c29">STXXL 1.4.1-382-g263df0c</a><script type="text/javascript">
var _paq = _paq || [];  _paq.push(['trackPageView']);  _paq.push(['enableLinkTracking']);  (function() {    var u='http://panthema.net/wik-331/';    _paq.push(['setTrackerUrl', u+'js/']);    _paq.push(['setSiteId', '1']);    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript';    g.defer=true; g.async=true; g.src=u+'js/'; s.parentNode.insertBefore(g,s);  })();
</script>
<noscript><img src="http://panthema.net/wik-331/js/?idsite=1&amp;rec=1" style="border:0" alt="" /></noscript> - Generated on Wed Sep 27 2017 06:26:37 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
