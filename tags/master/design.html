<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>STXXL: Design of STXXL</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-extra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">STXXL
   &#160;<span id="projectnumber">1.4-dev</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('design.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Design of STXXL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>Roman Dementiev (2006)</dd></dl>
<p>STXXL is a layered library consisting of three layers (see following figure). The lowest layer, the Asynchronous I/O primitives layer (AIO layer), abstracts away the details of how asynchronous I/O is performed on a particular operating system. Other existing external memory algorithm libraries only rely on synchronous I/O APIs <a class="el" href="citelist.html#CITEREF_CraMeh99">[25]</a> or allow reading ahead sequences stored in a file using the POSIX asynchronous I/O API <a class="el" href="citelist.html#CITEREF_tpie_manual">[9]</a>. These libraries also rely on uncontrolled operating system I/O caching and buffering in order to overlap I/O and computation in some way. However, this approach has significant performance penalties for accesses without locality. Unfortunately, the asynchronous I/O APIs are very different for different operating systems (e.g. POSIX AIO and Win32 Overlapped I/O). Therefore, we have introduced the AIO layer to make porting STXXL easy. Porting the whole library to a different platform requires only reimplementing the AIO layer using native file access methods and/or native multithreading mechanisms.</p>
<div class="image">
<img src="layer_diagram.png" alt="layer_diagram.png"/>
<div class="caption">
The STXXL library structure</div></div>
<p> STXXL already has several implementations of the AIO layer which use different file access methods under POSIX/UNIX and Windows systems. Porting STXXL to Windows took only a few days. The main efforts were spent for writing the AIO layer using the native Windows calls. Rewriting the thread-related code was easy provided the Boost thread library; its interfaces are similar to POSIX threads. There were little header file and compiler-specific incompatibilities; those were solved by conditional compilation using the C++ preprocessor. The POSIX version of STXXL had run immediately on the all listed operating systems after changing some Linux-specific header file includes to more common POSIX headers.</p>
<p>The Block Management layer (BM layer) provides a programming interface emulating the <b>parallel</b> disk model. The BM layer provides an abstraction for a fundamental concept in the external memory algorithm design &mdash; a block of elements. The block manager implements block allocation/deallocation, allowing several block-to-disk assignment strategies: striping, randomized striping, randomized cycling, etc. The block management layer provides an implementation of parallel disk buffered writing <a class="el" href="citelist.html#CITEREF_HutSanVit01b">[34]</a>, optimal prefetching <a class="el" href="citelist.html#CITEREF_HutSanVit01b">[34]</a>, and block caching. The implementations are fully asynchronous and designed to explicitly support overlapping between I/O and computation.</p>
<p>The top of STXXL consists of two modules. The STL-user layer provides external memory sorting, external memory stack, external memory priority queue, etc. which have (almost) the same interfaces (including syntax and semantics) as their STL counterparts. The Streaming layer provides efficient support for <b>pipelining</b> external memory algorithms. Many external memory algorithms, implemented using this layer, can save a factor of 2&ndash;3 in I/Os. For example, the algorithms for external memory suffix array construction implemented with this module <a class="el" href="citelist.html#CITEREF_DKMS05">[27]</a> require only 1/3 of the number of I/Os which must be performed by implementations that use conventional data structures and algorithms (either from STXXL STL-user layer, LEDA-SM, or TPIE). The win is due to an efficient interface that couples the input and the output of the algorithm&ndash;components (scans, sorts, etc.). The output from an algorithm is directly fed into another algorithm as input, without needing to store it on the disk in-between. This generic pipelining interface is the first of this kind for external memory algorithms.</p>
<h1><a class="anchor" id="aio_layer"></a>
The Asynchronous I/O primitives Layer</h1>
<p>The purpose of the AIO layer is to provide a unified approach to asynchronous I/O. The layer hides details of native asynchronous I/O interfaces of an operating system. Studying the patterns of I/O accesses of external memory algorithms and data structures, we have identified the following functionality that should be provided by the AIO layer:</p>
<ul>
<li>To issue read and write requests without having to wait for them to be completed.</li>
<li>To wait for the completion of a subset of issued I/O requests.</li>
<li>To wait for the completion of at least one request from a subset of issued I/O requests.</li>
<li>To poll the completion status of any I/O request.</li>
<li>To assign a callback function to an I/O request which is called upon I/O completion (asynchronous notification of completion status), with the ability to co-relate callback events with the issued I/O requests.</li>
</ul>
<p>The AIO layer exposes two user objects: <a class="el" href="classstxxl_1_1file.html">stxxl::file</a> and <a class="el" href="group__reqlayer.html#ga7f6ac626252081b4d28528770f32a19e">stxxl::request_ptr</a>. Together with the I/O waiting functions <a class="el" href="group__reqlayer.html#ga016f4e02b691aa4818ad3305de3f47bd">stxxl::wait_all</a>, <a class="el" href="group__reqlayer.html#ga3ff876fd05de0ef6217826a6b5459410">stxxl::wait_any</a>, and <a class="el" href="group__reqlayer.html#gaaca32bd3cecaa3edb11c46c670c1567e">stxxl::poll_any</a> they provide the functionality mentioned above. Using a <a class="el" href="classstxxl_1_1file.html">stxxl::file</a> object, the user can submit asynchronous read and asynchronous write requests (methods <a class="el" href="classstxxl_1_1file.html#ad4ed5ac8e2d25005716fa420f05c56c1">stxxl::file::aread</a> and <a class="el" href="classstxxl_1_1file.html#a3aabedede40fe8447134847a2feb5722" title="Schedules an asynchronous write request to the file. ">stxxl::file::awrite</a>). These methods return a <a class="el" href="group__reqlayer.html#ga7f6ac626252081b4d28528770f32a19e">stxxl::request_ptr</a> object which is used to track the status of the issued request. The AIO layer functions <a class="el" href="group__reqlayer.html#ga016f4e02b691aa4818ad3305de3f47bd">stxxl::wait_all</a>, <a class="el" href="group__reqlayer.html#ga3ff876fd05de0ef6217826a6b5459410">stxxl::wait_any</a>, and <a class="el" href="group__reqlayer.html#gaaca32bd3cecaa3edb11c46c670c1567e">stxxl::poll_any</a> facilitate tracking a set of <a class="el" href="group__reqlayer.html#ga7f6ac626252081b4d28528770f32a19e">stxxl::request_ptr</a> s. The last parameter of the methods <a class="el" href="classstxxl_1_1file.html#ad4ed5ac8e2d25005716fa420f05c56c1">stxxl::file::aread</a> and <a class="el" href="classstxxl_1_1file.html#a3aabedede40fe8447134847a2feb5722">stxxl::file::awrite</a> is a reference to a callback function object (callback functor). The functor's <code>operator()(request_ptr)</code> method is called when the I/O request is completed.</p>
<p>As a part of the AIO layer, the STXXL library provides various I/O performance counters (<a class="el" href="classstxxl_1_1stats.html">stxxl::stats</a> class). The class counts the number and the duration of the performed I/O operations as well as the transferred volume. Read and write operations are counted separately. STXXL also measures the time spent by the processing thread(s) waiting for the completions of I/Os (I/O wait time). This metric helps to evaluate the degree and the impact of overlapping between I/O and computation in an application.</p>
<p>The following listing shows a simple example of how to use AIO objects to perform asynchronous I/O. All STXXL library objects are defined in the namespace stxxl. For convenience, in line 1 we bring all names from the STXXL namespace to the local scope. In Line 8 a file object <code>myfile</code> is constructed. <a class="el" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a> is an implementation of the STXXL <a class="el" href="classstxxl_1_1file.html">stxxl::file</a> interface which uses UNIX/POSIX <code>read</code> and <code>write</code> system calls to perform I/O. The file named <code>"storage"</code> in the current directory is opened in read-only mode. In line 9 an asynchronous read of the 1 MB region of the file starting at position 0 is issued. The data will be read into the array <code>mybuffer</code>. When the read operation is completed, <code>my_handler::operator()</code> will be called with a pointer to the completed request. The execution stops at line 11 waiting for the completion of the issued read operation. Note that the work done in the function <code>do_something1()</code> is overlapped with reading. When the I/O is finished, one can process the read buffer (line 12) and free it (line 13).</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>my_handler { <span class="comment">// I/O completion handler</span></div>
<div class="line">    <span class="keywordtype">void</span> operator () (<a class="code" href="classstxxl_1_1counting__ptr.html">stxxl::request_ptr</a> ptr) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Request &#39;&quot;</span> &lt;&lt; *ptr &lt;&lt; <span class="stringliteral">&quot;&#39; completed.&quot;</span> &lt;&lt; std::endl;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"><span class="keywordtype">char</span> * mybuffer = <span class="keyword">new</span> <span class="keywordtype">char</span>[1024*1024]; <span class="comment">// allocate 1MB buffer</span></div>
<div class="line"><a class="code" href="classstxxl_1_1syscall__file.html">stxxl::syscall_file</a> myfile(<span class="stringliteral">&quot;./storage&quot;</span>, <a class="code" href="classstxxl_1_1file.html#a276dbe4d84ff07cd1489bce799a8bb4dacef691f6e56ce8f0e49154858a3e7bde">stxxl::file::RDONLY</a>);</div>
<div class="line"><a class="code" href="classstxxl_1_1counting__ptr.html">stxxl::request_ptr</a> myreq = myfile.aread(mybuffer, 0, 1024*1024, my_handler());</div>
<div class="line">do_something1(); <span class="comment">// do_something1() is overlapped with reading</span></div>
<div class="line">myreq-&gt;<a class="code" href="classstxxl_1_1request__interface.html#ac740c3dd58d02842bed4a4e86fe42b22">wait</a>();   <span class="comment">// wait for read completion</span></div>
<div class="line">do_something2(mybuffer);<span class="comment">// process the read buffer</span></div>
<div class="line"><span class="keyword">delete</span> [] mybuffer; <span class="comment">// free the buffer</span></div>
</div><!-- fragment --><h2><a class="anchor" id="aio_impl"></a>
AIO Layer Implementations</h2>
<p>There are several implementation strategies for the STXXL AIO layer. Some asynchronous I/O related APIs (and underlying libraries implementing them) already exist. The most well known framework is POSIX AIO, which has an implementation on almost every UNIX/POSIX system. Its disadvantage is that it has only limited support for I/O completion event mechanism The Linux AIO kernel side implementation (<a href="http://freshmeat.net/projects/linux-aio/">http://freshmeat.net/projects/linux-aio/</a>) of POSIX AIO does not have this deficit, but is not portable since it works under Linux only.</p>
<p>The STXXL AIO layer follows a different approach. It does not rely on any asynchronous I/O API. Instead we use synchronous I/O calls running asynchronously in separate threads. For each file there is one read and one write request queue and one thread. The main thread posts requests (invoking <a class="el" href="classstxxl_1_1file.html#ad4ed5ac8e2d25005716fa420f05c56c1">stxxl::file::aread()</a> and <a class="el" href="classstxxl_1_1file.html#a3aabedede40fe8447134847a2feb5722">stxxl::file::awrite()</a> methods) to the file queues. The thread associated with the file executes the requests in FIFO order. This approach is very flexible and it does not suffer from limitations of native asynchronous APIs.</p>
<p>Our POSIX implementation of the AIO layer is based on POSIX threads and supports several Unix file access methods: the <code>syscall</code> method uses <code>read</code> and <code>write</code> system calls, the <code>mmap</code> method uses memory mapping (<code>mmap</code> and <code>munmap</code> calls), the <code>sim_disk</code> method simulates I/O timings of a hard disk provided a big internal memory. To avoid superfluous copying of data between the user and kernel buffer memory, the <code>syscall</code> method has the option to use unbuffered file system access. These file access methods can also be used for raw disk I/O, bypassing the file system. In this case, instead of files, raw <b>device handles</b> are open. The <code>read/write</code> calls using direct access (<code>O_DIRECT</code> option) have shown the best performance under Linux. The disadvantage of the <code>mmap</code> call is that programs using this method have less control over I/O: In most operating systems 4 KBytes data pages of a <code>mmap</code>ed file region are brought to the main memory "lazily", only when they are accessed for the first time. This means if one <code>mmap</code>s a 100 KBytes block and touches only the first and the last element of the block then <b>two</b> I/Os are issued by the operating system. This will slow down many I/O-efficient algorithms, since for modern disks the seek time is much longer than the reading of 100 KBytes of contiguous data.</p>
<p>The POSIX implementation does not need to be ported to other UNIX compatible systems, since POSIX threads is the standard threading API on all POSIX-compatible operating systems.</p>
<p>Our Windows implementation is based on Boost threads, whose interfaces are very similar to POSIX threads.</p>
<p>AIO file and request implementation classes are derived from the generic <a class="el" href="classstxxl_1_1file.html">stxxl::file</a> and <a class="el" href="classstxxl_1_1request.html">stxxl::request</a> interface classes with C++ pure virtual functions. These functions are specialized for each access method in implementation classes to define the read, write, wait for I/O completion and other operations. The desired access method implementation for a file is chosen dynamically at running time. One can add the support of an additional access method (e.g. for a DAFS distributed filesystem) just providing classes implementing the <a class="el" href="classstxxl_1_1file.html">stxxl::file</a> and <a class="el" href="classstxxl_1_1request.html">stxxl::request</a> interfaces. We have decided to use the virtual function mechanism in the AIO layer because this mechanism is very flexible and <b>will not sacrifice</b> the performance of the library, since the virtual functions of the AIO layer need to be called only once per <b>large</b> chunk of data (i.e. <em>B</em> bytes). The inefficiencies of C++ virtual functions are well known. Similar to STL, the higher layers of STXXL do not rely on the running time polymorphism with virtual functions to avoid the high per-element penalties.</p>
<h1><a class="anchor" id="mng_layer"></a>
The Block-Management Layer</h1>
<p>The Block-Management (BM) layer provides an implementation of the central concept in I/O efficient algorithms and data structures: a block of elements (<a class="el" href="classstxxl_1_1typed__block.html">stxxl::typed_block</a> object). Besides, it includes a toolbox for allocating, deallocating, buffered writing, prefetching, and caching of blocks. The external memory manager (object <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a>) is responsible for allocating and deallocating external memory space on disks. The manager supports four parallel disk allocation strategies: simple striping, fully randomized, simple randomized <a class="el" href="citelist.html#CITEREF_BarGroVit97">[12]</a>, and randomized cycling <a class="el" href="citelist.html#CITEREF_VitHut01">[54]</a>.</p>
<p>The BM layer also delivers a set of helper classes that efficiently implement frequently used sequential patterns of interaction with the (parallel disk) external memory. The optimal parallel disk queued writing <a class="el" href="citelist.html#CITEREF_HutSanVit01b">[34]</a> is implemented in the <a class="el" href="classstxxl_1_1buffered__writer.html">stxxl::buffered_writer</a> class. The class operates on blocks. The <a class="el" href="classstxxl_1_1buf__ostream.html">stxxl::buf_ostream</a> class is build on top of <a class="el" href="classstxxl_1_1buffered__writer.html">stxxl::buffered_writer</a> and has a high level interface, similar to the interface of STL output iterators. Analogously, the classes <a class="el" href="classstxxl_1_1block__prefetcher.html">stxxl::block_prefetcher</a> and <a class="el" href="classstxxl_1_1buf__istream.html">stxxl::buf_istream</a> contain an implementation of an optimal parallel disk <b>prefetching</b> algorithm <a class="el" href="citelist.html#CITEREF_HutSanVit01b">[34]</a>. The helper objects of the BM layer support overlapping between I/O and computation, which means that they are able to perform I/O in the background, while the user thread is doing useful computations.</p>
<p>The BM layer views external memory as a set of large AIO files &mdash; one for each disk. We will refer to these files as <b>disks</b>. The other approach would be to map a related subset of blocks (e.g. those belonging to the same data structure) to a separate file. This approach has some performance problems. One of them is that since those (numerous) files are created dynamically, during the run of the program, the file system allocates the disk space on demand, that might in turn introduce severe uncontrolled disk space fragmentation. Therefore we have chosen the "one-large-file-per-disk" approach as our major scheme. However, the design of our library does not forbid data structures to store their content in separate user data files (e.g., as an option, <a class="el" href="classstxxl_1_1vector.html">stxxl::vector</a> can be mapped to a user file).</p>
<p>The external memory manager (object <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a>) is responsible for allocating and deallocating external memory space on the disks. The <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a> reads information about available disks from the STXXL configuration file. This file contains the location of each disk file, the sizes of the disks, and the file access methods for each disk. When allocating a bunch of blocks, a programmer can specify how the blocks will be assigned to disks, passing an allocation strategy function object. The <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a> implements the "first-fit" allocation heuristic <a class="el" href="citelist.html#CITEREF_BicShaw2003">[14]</a>. When an application requests several blocks from a disk, the manager tries to allocate the blocks contiguously. This reduces the bulk access time.</p>
<p>On allocation requests, the <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a> returns <a class="el" href="structstxxl_1_1BID.html">stxxl::BID</a> objects &ndash; Block IDentifiers. An object of the type <a class="el" href="structstxxl_1_1BID.html">stxxl::BID</a> describes the physical location of an allocated block, including the disk and offset of a region of storage on disk. One can load or store the data that resides at the location given by the <a class="el" href="structstxxl_1_1BID.html">stxxl::BID</a> using asynchronous <code>read</code> and <code>write</code> methods of a <a class="el" href="classstxxl_1_1typed__block.html">stxxl::typed_block</a> object.</p>
<p>The full signature of the STXXL "block of elements" class is <a class="el" href="classstxxl_1_1typed__block.html">stxxl::typed_block</a> The C++ template parameter RawSize defines the total size of the block in bytes. Since block size is not a single global constant in the STXXL namespace, a programmer can simultaneously operate with several block types having different blocks sizes. Such flexibility is often required for good performance. For example, B+-tree leaves might have a size different from the size of the internal nodes. We have made the block size a template parameter and not a member variable for the sake of efficiency. The values of the template parameters are known to the compiler, therefore for the power of two values (a very common choice) it can replace many arithmetic operations, like divisions and multiplications, by more efficient <b>binary shifts</b>. A critical requirement for many external memory data structures is that a block must be able to store links to other blocks. An STXXL block can store <code>NRef</code> objects of type <a class="el" href="structstxxl_1_1BID.html">stxxl::BID</a>. Additionally, one can equip a block with a field of the type <code>InfoType</code>, that can hold some per-block information. Block elements of type <code>T</code> can easily be accessed by the array <code>operator []</code> and via random access iterators. The maximum number of elements available a block depends on the number of links and the sizes of <code>T</code>, <code>InfoType</code> and <code><a class="el" href="structstxxl_1_1BID.html" title="Block identifier class. ">BID</a></code> types. This number is accessible as <a class="el" href="classstxxl_1_1typed__block.html#a3210d74166ef3a3c8ee6a9ca82617da3a1a740c88687d754c34c487e5bed0b25b">stxxl::typed_block::size</a>.</p>
<p>In the following listing, we give an example of how to program block I/O using objects of the BM layer. In line 2 we define the type of block: its size is one megabyte and the type of elements is <code>double</code>. The pointer to the only instance of the singleton object <a class="el" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a> is obtained in line 5. Line 6 asks the block manager to allocate 32 blocks in external memory. The <code>new_blocks</code> call writes the allocated BIDs to the output iterator, given by the last parameter. The <code>std::back_inserter</code> iterator adapter will insert the output BIDs at the end of the array <code>bids</code>. The manager assigns blocks to disks in a round-robin fashion as the <code>striping()</code> strategy suggests. Line 7 allocates 32 internal memory blocks. The internal memory allocator <a class="el" href="classstxxl_1_1new__alloc.html">stxxl::new_alloc</a>&lt;block_type&gt; of STXXL allocates blocks on a virtual memory page boundary, which is a requirement for unbuffered file access. Along lines 8&ndash;10 the elements of blocks are filled with some values. Then, the blocks are submitted for writing (lines 11-12). The request objects are stored in an <code>std::vector</code> for the further status tracking. As in the AIO example, I/O is overlapped with computations in the function <code>do_something()</code>. After the completion of all write requests (line 15) we perform some useful processing with the written data (function <code>do_something1()</code>). Finally we free the external memory space occupied by the 32 blocks (line 18).</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classstxxl_1_1typed__block.html">stxxl::typed_block&lt;1024*1024,double&gt;</a> block_type;</div>
<div class="line">std::vector&lt;block_type::bid_type&gt; bids; <span class="comment">//empty array of BIDs</span></div>
<div class="line">std::vector&lt;stxxl::request_ptr&gt; requests;</div>
<div class="line"><a class="code" href="classstxxl_1_1block__manager.html">stxxl::block_manager</a> * bm = <a class="code" href="classstxxl_1_1singleton.html#ab81b99f8fc8157a2a4b1bdab8afb454b">stxxl::block_manager::get_instance</a> ();</div>
<div class="line">bm-&gt;<a class="code" href="classstxxl_1_1block__manager.html#a5d1ba172819d3bf2969f3a1e35efabb5">new_blocks</a>&lt;block_type&gt;(32, <a class="code" href="structstxxl_1_1striping.html">stxxl::striping</a>(), std::back_inserter(bids));</div>
<div class="line">std::vector&lt; block_type, new_alloc&lt;block_type&gt; &gt; blocks(32);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; 32; ii++)</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj=0; jj &lt; block_type::size; jj++)</div>
<div class="line">        blocks[ii][jj] = some_value(ii,jj);</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 32; i++)</div>
<div class="line">    requests.push_back( blocks[i].write(bids[i]) );</div>
<div class="line">do_something(); <span class="comment">// do_something() is overlapped with writing</span></div>
<div class="line"><span class="comment">// wait until all I/Os finish</span></div>
<div class="line"><a class="code" href="group__reqlayer.html#ga016f4e02b691aa4818ad3305de3f47bd">stxxl::wait_all</a>(requests.begin(), requests.end());</div>
<div class="line">do_something1(bids.begin(),bids.end());</div>
<div class="line"><span class="comment">// deallocate external memory</span></div>
<div class="line">bm-&gt;<a class="code" href="group__mnglayer.html#ga1e37cfadb2eb22b38529bc2e85448fbc">delete_blocks</a>(bids.begin(), bids.end());</div>
</div><!-- fragment --><h1>The STL-User Layer</h1>
<p>The documentation of <a class="el" href="design_stl.html">The STL-User Layer</a> is on a separate subpage.</p>
<h1>The Algorithm Pipelining Layer</h1>
<p>The <a class="el" href="design_pipeline.html">Streaming layer</a> provides efficient support for external memory algorithms with mostly <b>sequential</b> I/O pattern, i.e. scan, sort, merge, etc. A user algorithm, implemented using this module can save many I/Os. The win is due to an efficient interface, that couples the input and the output of the algorithms-components (scans, sorts, etc.). The output from an algorithm is directly fed into another algorithm as the input, without the need to store it on the disk.</p>
<h1>Common Helpers and Utilities</h1>
<p>Beyond the layered library, STXXL contains many small helpers commonly used in C++ like random numbers or shared pointers. See <a class="el" href="common.html">Common Utilities and Helpers</a> for short descriptions. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="index.html">Welcome to STXXL</a></li>
    <li class="footer"><a href="http://github.com/stxxl/stxxl/commit/0a80a8c55993948f7f2f6c2c5a51ff45b403045b">STXXL 1.4.1-380-g0a80a8c</a><script type="text/javascript">
var _paq = _paq || [];  _paq.push(['trackPageView']);  _paq.push(['enableLinkTracking']);  (function() {    var u='http://panthema.net/wik-331/';    _paq.push(['setTrackerUrl', u+'js/']);    _paq.push(['setSiteId', '1']);    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0]; g.type='text/javascript';    g.defer=true; g.async=true; g.src=u+'js/'; s.parentNode.insertBefore(g,s);  })();
</script>
<noscript><img src="http://panthema.net/wik-331/js/?idsite=1&amp;rec=1" style="border:0" alt="" /></noscript> - Generated on Sat Feb 11 2017 06:26:28 for STXXL by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.5 </li>
  </ul>
</div>
</body>
</html>
